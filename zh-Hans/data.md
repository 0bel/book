# Data

众所周知，计算机以二进制——0 和 1——的方式保存和处理数据。然而，你可能需要一些时间来理解这实际上意味着什么。

为了说明一些问题，我们从一个例子开始：

```
0000011000001000000010110100010011100010101010101010101101001101
```

## 位和字节

[[CON]] 上述数据中的一个数字代表一个**位**（bit，比特）。它的符号是一个小写的 **b**。一个位只有两个可能的值，我们称它们为「关」和「开」。在原始数据中，我们可以用 0 和 1 来表示它们。上面的数据包含 64 位。

一个**字节**（byte）有 8 位长。它的符号是一个大写的 **B**。今天的计算机天生就能吃字节。计算机可以同时处理大量的字节。它们也能识别字节的起始位置。数据存储总是与字节对齐。因此，从不是字节起始位置的地方开始读取数据通常是没有意义的。你也会以字节而不是以位来读取数据。例子中的数据可以被分割成以下字节：

```
00000110 00001000 00001011 01000100 11100010 10101010 10101011 01001101
```

并且不存在以下两种情况：

```
00 00011000 00100000 00101101 00010011 10001010 10101010 10101101 001101
```

或

```
00000110 00001000 00001011 01000100 11100010 10101010 10101011 01001
```

一个字节可以写成一个两位数的十六进制数字，可以直接从二进制表示转换。例如，`11100100` 将被表示为 `E4`（按照惯例，如果有歧义，则以 `0x` 为前缀）。

## 地址

类似于只有整个字节是有用的，在某些情况下，只有一些字节组成的整个**块**是有用的。在这种情况下，原始数据的总长度是一个块大小的倍数，通常选择的字节数量是 2 的幂。在其他情况下，块的概念没有帮助，原始数据的长度可以是任何数量的字节。

一个**地址**是一个用来指定原始数据中的一个位置的数字。

**线性寻址**是一种为一段数据中的位置提供地址的非常简单的方法。 起始位置的地址为 0，对于每个后续字节或块，地址增加 1。

在我们的例子中，因为没有必要使用块，所以地址被赋给每个字节。这些是地址和它们相应的数据。

| 字节地址 | 数据（二进制）    | 数据（十六进制） |
| ---- | ---------- | -------- |
| `0`  | `00000110` | `06`     |
| `1`  | `00001000` | `08`     |
| `2`  | `00001011` | `0B`     |
| `3`  | `01000100` | `44`     |
| `4`  | `11100010` | `E2`     |
| `5`  | `10101010` | `AA`     |
| `6`  | `10101011` | `AB`     |
| `7`  | `01001101` | `4D`     |

我们从零开始计算地址和其他许多东西，这不仅仅是一种惯例。看看几个数字的十进制和二进制形式的表格，就知道为什么了。

|   十进制 |      二进制 |
| -------: | ----------: |
|        0 |  `00000000` |
|        1 |  `00000001` |
|       63 |  `00111111` |
|  2⁶ = 64 |  `01000000` |
|      255 |  `11111111` |
| 2⁸ = 256 | `100000000` |

注意二进制数字跳到第 7 和第 9 位的地方。因为保持数据长度不变有很多好处，所以我们要在一个 8 位数据中使用所有 2⁸ = 256 个可能的值。我们必须使用这种全部为零的组合，才能使用所有的 256 种组合。

## 对原始数据的操作

在大多数情况下，原始数据有一个固定的大小，不会变长或变短。

一般来说，在任何数据上，都可以有读和写的操作。在原始数据上，写意味着覆盖，将一个部分改变为所需的内容，并破坏现有的数据。在任何存储设备上按顺序读写所需的时间都与数据大小成正比。

当原来存在的数据不重要时，一块原始数据可以被称为空间。

## 数据是平凡的

这个例子的数据是什么意思？这个问题是无法回答的。就我们现在所学到的而言，一块原始数据是平凡的。这是为了让你牢记，原始数据只有在上下文中才会变得有意义。此外，当有一个上下文时，也应该有一个环境，将原始数据解释为更高层次的信息。

只是为了说明这一点，我们创建一个标准，以便为我们的例子数据提供一些「上下文」。对于上面的例子，你可以从头到尾一次读一个字节，把它们看作是整数。如果你按照这个结构，你会得到这些整数：

| 地址  | 数据         | 整数（十进制） |
| --- | ---------- | -------:|
| `0` | `00000110` | 6       |
| `1` | `00001000` | 8       |
| `2` | `00001011` | 11      |
| `3` | `01000100` | 68      |
| `4` | `11100010` | 226     |
| `5` | `10101010` | 170     |
| `6` | `10101011` | 171     |
| `7` | `01001101` | 77      |

但另一种情况是，有人可能设计了一个位图图像标准，其规则是。

- 第一个字节应该被解释为一个整数，是图像的宽度。
- 第二个字节应该被解释为一个整数，是图像的高度。
- 其余的数据位应该被解释为像素，从左上角开始，向右走，在每一行的末尾换行。

如果你按照这个结构，图像的宽度为 6，高度为 8，你将像这样把比特从 16 到 63 像这样换行：

```
000010
110100
010011
100010
101010
101010
101101
001101
```

而这种类型的图像查看器应该把这些 0 和 1 渲染成两种不同颜色的像素，排列方式如上。

所以现在你看到了上下文是如何将原始数据与更高层次的信息联系起来的。

## 单位

数据量的基本单位是字节和比特。我们在它们上面使用前缀来指定一个数量级。根据 IEC 80000-13 和国际单位制（SI）：

| 前缀 | 数量级 |             （计算后） |      | 前缀 | 数量级 |
| ---- | -----: | ---------------------: | ---- | ---- | -----: |
| Ki   |    2¹⁰ |                = 1 024 |      | K    |    10³ |
| Mi   |    2²⁰ |            = 1 048 576 |      | M    |    10⁶ |
| Gi   |    2³⁰ |        = 1 073 741 824 |      | G    |    10⁹ |
| Ti   |    2⁴⁰ |    = 1 099 511 627 776 |      | T    |   10¹² |
| Pi   |    2⁵⁰ | ≈ 1.125 899 907 × 10¹⁵ |      | P    |   10¹⁵ |
| Ei   |    2⁶⁰ | ≈ 1.152 921 505 × 10¹⁸ |      | E    |   10¹⁸ |
| Zi   |    2⁷⁰ | ≈ 1.180 591 621 × 10²¹ |      | Z    |   10²¹ |
| Yi   |    2⁸⁰ | ≈ 1.208 925 820 × 10²⁴ |      | Y    |   10²⁴ |

然而，有些地方的人并不使用这些标准。在正式开始工作之前，搞清楚和测试总是好的。

## 试一试

你可以用原始数据查看器查看任何文件和磁盘的任何部分。试试十六进制的数据编辑器。它可以让你看到十六进制的原始数据字节。然而，在你学习标准之前，你是无法解释它的，而且如果你随意编辑，很可能会损坏你的文件。记住在编辑文件之前要备份你的文件。除非你读过 [分区和文件系统](./partitioning-and-filesystem) 一章，否则不要直接编辑你的磁盘。
